import logging
import os
import asyncio

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
)
from aiogram import F
from outline_api import Manager
import time
from db import (
    init_db,
    add_key,
    clear_key,
    has_used_trial,
    get_active_key,
    record_referral,
    get_key_info,
    update_expiration,
    get_last_notification,
    set_last_notification,
    get_connection,
)

TOKEN = os.getenv("BOT_TOKEN")

logging.basicConfig(level=logging.INFO)

if not TOKEN:
    raise RuntimeError("BOT_TOKEN not configured")

bot = Bot(token=TOKEN)
dp = Dispatcher()

BOT_USERNAME: str | None = None

OUTLINE_API_URL = os.getenv("OUTLINE_API_URL")

DELETE_DELAY = int(os.getenv("DELETE_DELAY", "30"))

# Number of days granted to a referrer for each invited user
REFERRAL_BONUS_DAYS = 3

# Track scheduled deletion tasks so we can reschedule them
DELETION_TASKS: dict[tuple[int, bool], asyncio.Task] = {}

# Device links for Outline clients
DEVICE_LINKS = {
    "android": "https://play.google.com/store/apps/details?id=org.outline.android.client",
    "ios": "https://apps.apple.com/app/outline-app/id1356177741",
    "windows": "https://getoutline.org/",
    "macos": "https://getoutline.org/",
    "androidtv": "https://play.google.com/store/apps/details?id=org.outline.android.client",
}


async def get_bot_username() -> str:
    global BOT_USERNAME
    if BOT_USERNAME is None:
        me = await bot.get_me()
        BOT_USERNAME = me.username
    return BOT_USERNAME


async def send_temporary(
    bot: Bot, chat_id: int, text: str, delay: int = DELETE_DELAY, **kwargs
) -> types.Message:
    msg = await bot.send_message(chat_id, text, **kwargs)

    async def _remove() -> None:
        await asyncio.sleep(delay)
        try:
            await bot.delete_message(chat_id, msg.message_id)
        except Exception as exc:
            logging.error("Failed to delete message: %s", exc)

    asyncio.create_task(_remove())
    return msg


def outline_manager() -> Manager:
    if not OUTLINE_API_URL:
        raise RuntimeError("OUTLINE_API_URL not configured")
    return Manager(apiurl=OUTLINE_API_URL, apicrt="")


async def create_outline_key(label: str | None = None) -> dict:
    manager = outline_manager()
    key = await asyncio.to_thread(manager.new, label)
    if label and "id" in key:
        try:
            await asyncio.to_thread(manager.rename, key["id"], label)
        except Exception as exc:
            logging.error("Failed to rename Outline key: %s", exc)
    return key


def schedule_key_deletion(
    key_id: int,
    delay: int = 24 * 60 * 60,
    user_id: int | None = None,
    is_trial: bool | None = None,
) -> asyncio.Task:
    """Schedule Outline key removal and return the created task."""

    async def _remove() -> None:
        await asyncio.sleep(delay)
        manager = outline_manager()
        try:
            await asyncio.to_thread(manager.delete, key_id)
        except Exception as exc:
            logging.error("Failed to delete Outline key: %s", exc)
        if user_id is not None and is_trial is not None:
            await clear_key(user_id, is_trial)
            DELETION_TASKS.pop((user_id, is_trial), None)

    if user_id is not None and is_trial is not None:
        old = DELETION_TASKS.pop((user_id, is_trial), None)
        if old:
            old.cancel()
    task = asyncio.create_task(_remove())
    if user_id is not None and is_trial is not None:
        DELETION_TASKS[(user_id, is_trial)] = task
    return task


async def send_activation_prompt(chat_id: int, access_url: str, expires_at: int) -> None:
    """Send activation info and device selection keyboard in three messages."""
    date_str = time.strftime("%d.%m.%Y", time.localtime(expires_at))
    first = (
        f"\U0001f389 \u0414\u043e\u0441\u0442\u0443\u043f \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u043e\u0432\u0430\u043d \u0434\u043e {date_str}\n\n"
        "\U0001f511 \u0412\u0430\u0448 VPN-\u043a\u043b\u044e\u0447:"
    )
    second = access_url
    third = (
        "\U0001f4f2 \u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0432\u043e\u0451 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442 \u0438 \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044e:"
    )

    kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="\U0001f4f1 Android", callback_data="device_android"),
                InlineKeyboardButton(text="\U0001f34f iOS", callback_data="device_ios"),
            ],
            [
                InlineKeyboardButton(text="\U0001f4bb Windows", callback_data="device_windows"),
                InlineKeyboardButton(text="\U0001f5a5 MacOS", callback_data="device_macos"),
            ],
            [
                InlineKeyboardButton(text="\U0001f4fa Android TV", callback_data="device_androidtv"),
            ],
        ]
    )

    await bot.send_message(chat_id, first)
    await bot.send_message(chat_id, second)
    await bot.send_message(chat_id, third, reply_markup=kb)


async def notify_expirations_loop(interval: int = 60 * 60) -> None:
    """Periodically check VPN subscriptions and send reminders."""
    while True:
        now = int(time.time())
        async with get_connection() as conn:
            cursor = await conn.execute(
                "SELECT user_id, expires_at FROM vpn_access "
                "WHERE key_id IS NOT NULL AND expires_at IS NOT NULL AND is_trial=0"
            )
            rows = await cursor.fetchall()
        for user_id, expires_at in rows:
            if expires_at is None:
                continue
            days_left = (expires_at - now + 86399) // 86400
            last = await get_last_notification(user_id)
            if last and now - last < 24 * 60 * 60:
                continue
            text = None
            if days_left == 3:
                text = (
                    "\u23f3 \u041d\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c: "
                    "\u0441\u0440\u043e\u043a \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f "
                    "\u0432\u0430\u0448\u0435\u0433\u043e VPN \u0441\u043a\u043e\u0440\u043e \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u0441\u044f!\n"
                    "\ud83d\udcc5 \u041e\u0441\u0442\u0430\u043b\u043e\u0441\u044c \u0432\u0441\u0435\u0433\u043e 3 \u0434\u043d\u044f. \u041d\u0435 \u0437\u0430\u0431\u0443\u0434\u044c\u0442\u0435 \u043f\u0440\u043e\u0434\u043b\u0438\u0442\u044c.\n"
                    "\ud83d\udd25 \u041f\u0440\u043e\u0434\u043b\u0438\u0442\u0435 \u043f\u043e\u0434\u043f\u0438\u0441\u043a\u0443 \u043f\u0440\u044f\u043c\u043e \u0441\u0435\u0439\u0447\u0430\u0441 \u2014 \u044d\u0442\u043e \u0437\u0430\u0439\u043c\u0451\u0442 \u043d\u0435 \u0431\u043e\u043b\u044c\u0448\u0435 \u043c\u0438\u043d\u0443\u0442\u044b!"
                )
            elif days_left <= 0:
                if days_left == 0:
                    text = (
                        "\ud83d\udeab \u0421\u0440\u043e\u043a \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0432\u0430\u0448\u0435\u0433\u043e VPN \u0437\u0430\u043a\u043e\u043d\u0447\u0438\u043b\u0441\u044f.\n"
                        "\ud83d\udd25 \u041f\u0440\u043e\u0434\u043b\u0438 \u043d\u0430 30 \u0434\u043d\u0435\u0439 \u0432\u0441\u0435\u0433\u043e \u0437\u0430 [\u0446\u0435\u043d\u0443]\n"
                        "\u25b6\ufe0f \u041d\u0430\u0436\u043c\u0438\u0442\u0435 /\u043f\u0440\u043e\u0434\u043b\u0438\u0442\u044c \u2014 \u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0441\u044f \u0432 \u0441\u0447\u0438\u0442\u0430\u043d\u043d\u044b\u0435 \u043c\u0438\u043d\u0443\u0442\u044b!"
                    )
                else:
                    text = (
                        "\u23f3 \u041d\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c: "
                        "\u0432\u0430\u0448 VPN \u043f\u043e-\u043f\u0440\u0435\u0436\u043d\u0435\u043c\u0443 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d.\n"
                        "\ud83d\udca1 \u041f\u0440\u043e\u0434\u043b\u0435\u043d\u0438\u0435 \u0437\u0430\u0439\u043c\u0451\u0442 \u043c\u0438\u043d\u0443\u0442\u0443, \u0430 \u0434\u043e\u0441\u0442\u0443\u043f \u2014 \u043d\u0430 \u043c\u0435\u0441\u044f\u0446!\n"
                        "\ud83d\udd25 \u041d\u0430\u0436\u043c\u0438\u0442\u0435 /\u043f\u0440\u043e\u0434\u043b\u0438\u0442\u044c \u0438 \u0432\u0435\u0440\u043d\u0438\u0442\u0435\u0441\u044c \u043a \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u0438 \u0441\u0432\u043e\u0431\u043e\u0434\u0435 \ud83d\udee1"
                    )
            if text:
                try:
                    await bot.send_message(user_id, text)
                    await set_last_notification(user_id, now)
                except Exception as exc:
                    logging.error("Failed to send notification: %s", exc)
        await asyncio.sleep(interval)


async def grant_referral_bonus(referrer_id: int) -> None:
    """Issue a 3 day key for the referrer."""
    bonus_seconds = REFERRAL_BONUS_DAYS * 24 * 60 * 60
    now_ts = int(time.time())
    label = f"ref_bonus_{referrer_id}_{now_ts}"
    try:
        key = await create_outline_key(label=label)
        expires = now_ts + bonus_seconds
        await add_key(referrer_id, key.get("id"), key.get("accessUrl"), expires, False)
        schedule_key_deletion(
            key.get("id"), delay=bonus_seconds, user_id=referrer_id, is_trial=False
        )

        logging.info("Issued referral key %s for user %s", key.get("id"), referrer_id)

        await send_activation_prompt(
            referrer_id,
            key.get("accessUrl", "Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ"),
            expires,
        )
    except Exception as exc:
        logging.error("Failed to create referral key: %s", exc)


@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    first_name = message.from_user.first_name or "Ð´ÑÑÐ³"
    args = message.text.split(maxsplit=1)
    if len(args) > 1 and args[1].startswith("ref"):
        try:
            ref_id = int(args[1][3:])
        except ValueError:
            ref_id = None
        if ref_id is not None:
            if await record_referral(message.from_user.id, ref_id):
                logging.info(
                    "User %s joined via referral from %s",
                    message.from_user.id,
                    ref_id,
                )
                await grant_referral_bonus(ref_id)
    await message.answer(f"ÐÑÐ¸Ð²ÐµÑ, {first_name}! \U0001f44b")

    text = (
        "ÐÑ â ÐÐ¸ÑÐ¾Ð²ÑÐµ Ð°Ð½ÐµÐºÐ´Ð¾ÑÑ, Ð¸ Ð´Ð°, Ñ Ð½Ð°Ñ ÐµÑÑÑ ÑÐ²Ð¾Ð¹ VPN, ÐºÐ¾ÑÐ¾ÑÑÐ¹ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ ÑÐ°Ðº Ð¶Ðµ Ð½Ð°Ð´ÑÐ¶Ð½Ð¾, "
        "ÐºÐ°Ðº ÑÐ¾ÑÐ¾ÑÐ°Ñ ÑÑÑÐºÐ° Ð·Ð°ÑÐ¾Ð´Ð¸Ñ Ð² Ð¿ÑÑÐ½Ð¸ÑÑ Ð²ÐµÑÐµÑÐ¾Ð¼ \U0001f60f\n\n"
        "ÐÐ¾ÑÐµÐ¼Ñ Ð²ÑÐ±Ð¸ÑÐ°ÑÑ ÐÐ¸ÑÐ¾Ð²ÑÐµ Ð°Ð½ÐµÐºÐ´Ð¾ÑÑ?\n\n"
        "\u2705 ÐÑÐ¸Ð²Ð°ÑÐ½ÑÐ¹ ÑÐµÑÐ²ÐµÑ â Ð²Ð°Ñ Ð½Ð¸ÐºÑÐ¾ Ð½Ðµ ÑÐ²Ð¸Ð´Ð¸Ñ Ð¸ Ð½Ðµ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸ÑÑÐµÑ\n"
        "\U0001f680 Ð¡ÐºÐ¾ÑÐ¾ÑÑÑ Ð´Ð¾ 1 ÐÐ±Ð¸Ñ/ÑÐµÐº â Ð»ÐµÑÐ°ÐµÑ, ÐºÐ°Ðº ÑÐ¼ÐµÑ Ð² ÑÐ¾ÑÐ¾ÑÐµÐ¹ ÐºÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ð¸\n"
        "\U0001f4f5 ÐÐµÐ· ÑÐµÐºÐ»Ð°Ð¼Ñ Ð¸ Ð²ÑÐ»ÐµÑÐ¾Ð² â Ð½Ð¸ÑÐµÐ³Ð¾ Ð½Ðµ ÑÐ°Ð·Ð´ÑÐ°Ð¶Ð°ÐµÑ\n"
        "\U0001f4ca ÐÐµÐ·Ð»Ð¸Ð¼Ð¸ÑÐ½ÑÐ¹ ÑÑÐ°ÑÐ¸Ðº â Ð½Ð¸ÐºÐ°ÐºÐ¸Ñ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ð¹, ÑÐ¾ÑÑ ÑÑÑÐºÐ¸ Ð½Ð°Ð¿ÑÐ¾Ð»ÑÑ\n"
        "\U0001f6e1 100% Ð·Ð°ÑÐ¸ÑÐ° Ð´Ð°Ð½Ð½ÑÑ â Ð²ÑÑ Ð¿Ð¾-Ð²Ð·ÑÐ¾ÑÐ»Ð¾Ð¼Ñ, ÑÐ¾Ð»ÑÐºÐ¾ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÑ\n"
        "\U0001f4f1 ÐÐ¾Ð´Ð´ÐµÑÐ¶ÐºÐ°: iOS, Android, Windows, MacOS, Android TV\n\n"
        "ÐÐ¸ÑÐ¾Ð²ÑÐµ Ð°Ð½ÐµÐºÐ´Ð¾ÑÑ â ÑÑÐ¾ Ð½Ðµ ÑÐ¾Ð»ÑÐºÐ¾ Ð¿ÑÐ¾ Ð²ÐµÑÑÐ»Ð¾Ðµ Ð½Ð°ÑÑÑÐ¾ÐµÐ½Ð¸Ðµ,\n"
        "Ð° ÐµÑÑ Ð¸ Ð¿ÑÐ¾ ÑÐ²Ð¾Ð±Ð¾Ð´Ñ Ð´Ð¾ÑÑÑÐ¿Ð° Ð² Ð¸Ð½ÑÐµÑÐ½ÐµÑÐµ \U0001f680"
    )

    inline_kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="\U0001f511 ÐÑÐ¾Ð±Ð½ÑÐ¹ Ð¿ÐµÑÐ¸Ð¾Ð´", callback_data="trial"
                )
            ]
        ]
    )

    reply_kb = ReplyKeyboardMarkup(
        keyboard=[
            [
                KeyboardButton(text="\U0001f6d2 ÐÑÐ¿Ð¸ÑÑ VPN | \U0001f4c5 ÐÑÐ¾Ð´Ð»Ð¸ÑÑ"),
                KeyboardButton(text="\U0001f511 ÐÐ¾Ð¸ Ð°ÐºÑÐ¸Ð²Ð½ÑÐµ ÐºÐ»ÑÑÐ¸"),
            ],
            [
                KeyboardButton(text="\U0001f9d1\u200d\U0001f4ac ÐÑÐ·ÑÐ²Ñ"),
                KeyboardButton(text="\U0001f381 ÐÑÐ¸Ð³Ð»Ð°ÑÐ¸ÑÑ"),
            ],
            [KeyboardButton(text="\U0001f198 ÐÐ¾Ð¼Ð¾ÑÑ")],
        ],
        resize_keyboard=True,
    )

    await message.answer(text, reply_markup=inline_kb)
    await message.answer("ÐÑÐ±ÐµÑÐ¸ÑÐµ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ:", reply_markup=reply_kb)


@dp.callback_query(F.data == "trial")
async def callback_trial(callback: types.CallbackQuery):
    if await has_used_trial(callback.from_user.id):
        await send_temporary(
            bot,
            callback.message.chat.id,
            "ÐÑ ÑÐ¶Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð»Ð¸ Ð¿ÑÐ¾Ð±Ð½ÑÐ¹ Ð¿ÐµÑÐ¸Ð¾Ð´.",
        )
    else:
        try:
            key = await create_outline_key(label=f"vpn_{callback.from_user.id}")
            expires = int(time.time() + 24 * 60 * 60)
            await add_key(
                callback.from_user.id,
                key.get("id"),
                key.get("accessUrl"),
                expires,
                True,
            )
            schedule_key_deletion(
                key.get("id"),
                delay=24 * 60 * 60,
                user_id=callback.from_user.id,
                is_trial=True,
            )
            await send_activation_prompt(
                callback.message.chat.id,
                key.get("accessUrl", "Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ"),
                expires,
            )
        except Exception as exc:
            logging.error("Failed to create trial key: %s", exc)
            await send_temporary(
                bot,
                callback.message.chat.id,
                "ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ Ð¿ÑÐ¾Ð±Ð½ÑÐ¹ ÐºÐ»ÑÑ.",
            )
    await callback.answer()


@dp.callback_query(F.data.startswith("device_"))
async def callback_device(callback: types.CallbackQuery):
    device = callback.data.split("_", 1)[1]
    link = DEVICE_LINKS.get(device)
    row = await get_key_info(callback.from_user.id)
    if not row:
        await callback.message.answer("\u041a\u043b\u044e\u0447 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d.")
        await callback.answer()
        return
    _, access_url, _, _ = row
    first = (
        f"\u2705 \u0421\u043a\u0430\u0447\u0430\u0442\u044c Outline Client: {link}\n\n"
        "\u2705 \u0412\u0430\u0448 \u043a\u043b\u044e\u0447:"
    )
    second = access_url
    third = (
        "\u041d\u0430\u0436\u043c\u0438\u0442\u0435 '+' , \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 '\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043b\u044e\u0447 \u0432\u0440\u0443\u0447\u043d\u0443\u044e', \u0432\u0441\u0442\u0430\u0432\u044c\u0442\u0435 \u0441\u0441\u044b\u043b\u043a\u0443 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u043b\u0438 \u0432\u044b\u0448\u0435\n\u0413\u043e\u0442\u043e\u0432\u043e, \u0442\u0435\u043f\u0435\u0440\u044c VPN \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d \u043d\u0430 \u0432\u0430\u0448\u0435 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e"
    )
    await callback.message.answer(first)
    await callback.message.answer(second)
    await callback.message.answer(third)
    await callback.answer()


@dp.callback_query(F.data == "main_menu")
async def callback_main_menu(callback: types.CallbackQuery):
    await cmd_start(callback.message)
    await callback.answer()


@dp.message(Command("menu"))
async def cmd_menu(message: types.Message):
    await cmd_start(message)


@dp.message(Command("help"))
async def cmd_help(message: types.Message):
    await menu_help(message)


@dp.message(F.text == "\U0001f511 ÐÐ¾Ð¸ Ð°ÐºÑÐ¸Ð²Ð½ÑÐµ ÐºÐ»ÑÑÐ¸")
async def menu_keys(message: types.Message):
    row = await get_active_key(message.from_user.id)
    now_ts = int(time.time())
    if row:
        access_url, expires_at, is_trial = row
        if expires_at is not None and expires_at <= now_ts:
            await clear_key(message.from_user.id, bool(is_trial))
            await send_temporary(bot, message.chat.id, "Ð¡ÑÐ¾Ðº Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð²Ð°ÑÐµÐ³Ð¾ ÐºÐ»ÑÑÐ° Ð¸ÑÑÑÐº.")
        else:
            date_str = time.strftime("%d.%m.%Y", time.localtime(expires_at))
            await send_temporary(
                bot, message.chat.id, f"\U0001f511 ÐÐ°Ñ ÐºÐ»ÑÑ Ð°ÐºÑÐ¸Ð²ÐµÐ½ Ð´Ð¾ {date_str}"
            )
            await send_temporary(bot, message.chat.id, access_url)
    else:
        await send_temporary(bot, message.chat.id, "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð°ÐºÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ ÐºÐ»ÑÑÐ°.")


@dp.message(F.text == "\U0001f9d1\u200d\U0001f4ac ÐÑÐ·ÑÐ²Ñ")
async def menu_reviews(message: types.Message):
    await send_temporary(bot, message.chat.id, 'Ð Ð°Ð·Ð´ÐµÐ» "ÐÑÐ·ÑÐ²Ñ" Ð¿Ð¾ÐºÐ° Ð² ÑÐ°Ð·ÑÐ°Ð±Ð¾ÑÐºÐµ')


@dp.message(F.text == "\U0001f6d2 ÐÑÐ¿Ð¸ÑÑ VPN | \U0001f4c5 ÐÑÐ¾Ð´Ð»Ð¸ÑÑ")
async def menu_buy(message: types.Message):
    text = (
        "\U0001f525 ÐÑÐ¾ÑÐ¼Ð»ÑÑ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÑ Ð½Ð° Premium VPN Ð¾Ñ ÐÐ¸ÑÐ¾Ð²ÑÐµ Ð°Ð½ÐµÐºÐ´Ð¾ÑÑ â "
        "Ð²Ñ Ð¿Ð¾Ð»ÑÑÐ°ÐµÑÐµ: \U0001f447\n\n"
        "â ð ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð¸ ÑÑÐ°Ð±Ð¸Ð»ÑÐ½Ð¾Ðµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ  \n"
        "â ð¥ ÐÐ¿ÐµÑÐ°ÑÐ¸Ð²Ð½ÑÑ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÑ Ð² ÑÐ°ÑÐµ â @andekdot_support  \n"
        "â ð¥ ÐÐ¾ÑÑÑÐ¿ Ñ Ð»ÑÐ±ÑÑ ÑÑÑÑÐ¾Ð¹ÑÑÐ² â iOS, Android, Windows, MacOS, Android TV  \n"
        "â ð ÐÐ´Ð¸Ð½ ÐºÐ»ÑÑ â Ð¾Ð´Ð½Ð¾ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾ (Ð²ÑÑ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾)  \n"
        "â ð  ÐÐ¾Ð´ÑÐ¾Ð±Ð½Ð°Ñ Ð¸Ð½ÑÑÑÑÐºÑÐ¸Ñ + Ð²Ð¸Ð´ÐµÐ¾ â Ð·Ð°Ð¿ÑÑÑÐ¸ÑÐµ VPN Ð·Ð° 2 Ð¼Ð¸Ð½ÑÑÑ  \n"
        "â â ÐÐµÐ·Ð»Ð¸Ð¼Ð¸ÑÐ½ÑÐ¹ ÑÑÐ°ÑÐ¸Ðº â Ð½Ð¸ÐºÐ°ÐºÐ¸Ñ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ð¹  \n"
        "â ð ÐÐµÐ· ÑÐµÐºÐ»Ð°Ð¼Ñ â Ð½Ð¸ÑÑÐ¾ Ð½Ðµ Ð¼ÐµÑÐ°ÐµÑ  \n"
        "â âï¸ ÐÐµÐ· Ð°Ð²ÑÐ¾ÑÐ¿Ð¸ÑÐ°Ð½Ð¸Ð¹ â Ð²ÑÑ Ð¿Ð¾Ð´ Ð²Ð°ÑÐ¸Ð¼ ÐºÐ¾Ð½ÑÑÐ¾Ð»ÐµÐ¼\n\n"
        "ð¥ ÐÐ°Ðº Ð¾Ð¿Ð»Ð°ÑÐ¸ÑÑ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÑ?  \n"
        "ð Ð¡Ð¼Ð¾ÑÑÐ¸ÑÐµ Ð²Ð¸Ð´ÐµÐ¾: ÑÑÐº ÑÑÐ´Ð°\n\n"
        "ð¡ Ð¡Ð¾Ð²ÐµÑ: ÑÐµÐ¼ Ð´Ð¾Ð»ÑÑÐµ ÑÑÐ¾Ðº, ÑÐµÐ¼ Ð½Ð¸Ð¶Ðµ ÑÐµÐ½Ð° Ð·Ð° Ð¼ÐµÑÑÑ ð  \n"
        "â¶ï¸ ÐÑÐ±ÐµÑÐ¸ÑÐµ Ð½ÑÐ¶Ð½ÑÐ¹ ÑÐ°ÑÐ¸Ñ Ð½Ð¸Ð¶Ðµ Ð¸ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°Ð¹ÑÐµÑÑ ÑÐ¶Ðµ ÑÐµÐ³Ð¾Ð´Ð½Ñ!"
    )

    tariff_kb = ReplyKeyboardMarkup(
        keyboard=[
            [
                KeyboardButton(text="\U0001f7e1 1 Ð¼ÐµÑ â 199\u20bd"),
                KeyboardButton(text="\U0001f7e2 3 Ð¼ÐµÑ â 529\u20bd"),
                KeyboardButton(text="\U0001f7e2 6 Ð¼ÐµÑ â 949\u20bd"),
            ],
            [KeyboardButton(text="\U0001f7e3 12 Ð¼ÐµÑ â 1659\u20bd")],
            [KeyboardButton(text="\U0001f4a0 ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½Ñ")],
        ],
        resize_keyboard=True,
    )

    await message.answer(text, reply_markup=tariff_kb)


@dp.message(F.text == "\U0001f381 ÐÑÐ¸Ð³Ð»Ð°ÑÐ¸ÑÑ")
async def menu_invite(message: types.Message):
    first_name = message.from_user.first_name or "Ð´ÑÑÐ³"
    username = await get_bot_username()
    link = f"https://t.me/{username}?start=ref{message.from_user.id}"
    text = (
        f"{first_name}, ÑÑ Ð·Ð½Ð°Ð»(Ð°)\U0001f914, ÑÑÐ¾ Ð·Ð° ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¿ÑÐ¸Ð³Ð»Ð°ÑÐµÐ½Ð½Ð¾Ð³Ð¾ Ð´ÑÑÐ³Ð°, "
        f"ÑÑ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ \U0001f4c5 {REFERRAL_BONUS_DAYS} Ð´Ð½Ñ VPN \U0001f310 Ð² Ð¿Ð¾Ð´Ð°ÑÐ¾Ðº \U0001f381?\n\n"
        "ÐÐ¾Ñ ÑÐ²Ð¾Ñ ÑÐµÑÐµÑÐ°Ð»ÑÐ½Ð°Ñ ÑÑÑÐ»ÐºÐ° \U0001f60a:\n"
        f"{link}"
    )
    inline_kb = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="\U0001f4e3 ÐÐ¾Ð´ÐµÐ»Ð¸ÑÑÑÑ", switch_inline_query=link
                )
            ],
            [
                InlineKeyboardButton(
                    text="\U0001f4a0 ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½Ñ", callback_data="main_menu"
                )
            ],
        ]
    )
    await message.answer(text, reply_markup=inline_kb)


@dp.message(F.text == "\U0001f198 ÐÐ¾Ð¼Ð¾ÑÑ")
async def menu_help(message: types.Message):
    await send_temporary(bot, message.chat.id, 'Ð Ð°Ð·Ð´ÐµÐ» "ÐÐ¾Ð¼Ð¾ÑÑ" Ð¿Ð¾ÐºÐ° Ð² ÑÐ°Ð·ÑÐ°Ð±Ð¾ÑÐºÐµ')


@dp.message(F.text == "\U0001f4a0 ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½Ñ")
async def back_to_menu(message: types.Message):
    await cmd_start(message)


async def main() -> None:
    await init_db()
    asyncio.create_task(notify_expirations_loop())
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
